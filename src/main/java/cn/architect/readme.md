记录，来自从0开始学架构。

三、复杂度来源：单台服务器变多台，单台负债均衡机器变多台(来源用户分配到不同负债均衡机，可DNS轮询、全局负债均衡器等)，多对多情况。这是在业务不变的情况下提升性能。
但若业务越来越负债，则单台服务器处理性能会产生瓶颈，就需要对业务的拆分了，比如微信拆分了漂流瓶、聊天等模块，并不是越细越好，不同模块之间调用的网络传输也占用了时间，比如1ms

换个角度看，其实可通过垂直和水平两个维度做高性能，垂直针对单台服务，软硬件提升，增加内存减少I/O，升级网络接口。
水平针对集群系统主要通过任务分配和任务分解提升。功能分解、多实例副本、数据分割比如MongoDB数据分片。

四、高可用来源：主要技术手段是服务与数据的冗余备份和失效转移。在于系统“无中断”，通过“冗余”解决，增加机器，或机房。通道可能故障，则用两条甚至三条(移动电信联通)。增加机器需要任务分配器，双机分配器算法常见的有主备(冷备、温备、热备)、主主。而还有高可用集群，分配算法有1主3备，2主2备...4主0备等，zookeeper是1主多备，memcached是全主0备。
    计算高可用只需要加机器即可，存储高可用要考虑数据不一致问题。比如数据传输，尤其是跨机房，带来的延迟以及网络异常情况。也是CAP定理，即一致性、可用性、分区容错性，最多同时满足两个。
    冗余的高可用系统，状态决策相当重要，而一般有几种类型，独裁式(决策者本身可能有问题)、协商式(比如主备通信，协商选决策者。主备之间可能连接中断导致信息交换失败)、民主式(比如zookeeper集群通过多个独立个体投票进行状态决策，多数取胜，算法Paxos。另外也会有脑裂问题，即多决策者)，记得和朋友聊过，还可以通过每间隔一段时间争抢缓存锁(缓存值有过期时间)来选主。
    
    硬件故障引起的技术解决措施：1应用服务器(实现业务逻辑)，通过负载均衡构建集群(这些服务需要为无状态、即应用服务器不保存业务上下文)，通过心跳监控是否服务正常，不正常则剔除。2服务层服务器，一般通过rpc提供服务(例如dubbo)，给应用服务调用。3数据服务器，需在数据写入时进行数据同步复制，将数据写入多台服务器，实现冗余备份，当数据服务器宕机，应用程序切换到有备份的机器。
    软件一起的不可用解决措施：通过开发流程进行保证。比如通过预发布验证、测试、灰度发布等。

五、复杂度之可扩展性:在技术上，方案1将可能变化部分设计成变化层、不变层另外设计.方案2提炼出一个“抽象层”和一个实现层。
实际解决方案：1使用分布式服务框架构建可复用的业务平台(如dubbo拆分模块)，2使用分布式消息队列降低业务模块间的耦合性。

六、复制度之低成本-安全-规模:一般低成本，伴随着引入新技术或自创新技术了，比如Nosql出现是为了解决关系型数据库无法应对的高并发访问带来的访问压力，全文搜索引擎(es、solr等)是为了解决关系型数据库like搜索的低效问题，Hadoop是为了解决传统文件系统无法应对海量数据存储和计算的问题。新浪微博将传统的redis/mc+mysql扩展为redis/mc+ssd cache+mysql，解决redis成本过高和容量小问题，也解决了穿透DB带来的数据库访问压力。linkedin为处理5千亿事件，开发高效kafka。安全方面，像ddos攻击，一般通过运营商或云服务商提高带宽和流量清洗能力解决。
另外，画图方面，架构图推荐4+1画图。

14、数据库集群-读写分离：主从延迟和分配机制，<br>
首先复制延迟常见方案，(1)写后的读操作发给主，业务代码侵入。（2）读从机失败后读主，二次读取容易造成主压力大。（3）关键业务读写都在主，非关键业务用读写分离。其实也可通过缓存redis来解决<br>
分配机制有两种，程序代码封装和中间件封装。比如程序代码可在hibernate封装一层实现，以及成熟的TDDL，但每种语言要各自实现一份，且主从切换，可能要修改配置并重启服务。而中间件是数据库管理，能支持多种语言，主从动态切换，比如MySQL Router。

15、数据库分库分表：垂直分、水平分。<br>
    路由规则，可通过路由表，也可以hash路由。<br>
    其中join操作可通过分别每个库表操作，再汇总。<br>
    而count也同理，比如文章的总数，用来分页，也可通过加一个冗余字段记录每个库表的count数量，但会有数据一致性问题。<br>
    另外，分库分表业务实现，也同样是“程序代码封装”和“中间件封装”两种。根据sql具体的表名、函数名(例如sum函数)，分别执行并汇总。<br>
    
16、NoSQL:常见的分为4类，<br>
    K-V存储：解决关系数据库无法存储数据结构的问题，redis为代表。含有string、hash、list、set、sorted set等结构。<br>
    文档数据库：解决关系数据库强schema约束的问题，MongoDB为代表。特点是no-ch<br>
    列式数据库：解决关系数据库大数据场景下I/O问题，HBase为代表。<br>
    全文搜索引擎：解决关系数据库的全文搜索性能问题，Elasticsearch为代表。<br>
    其中，Elasticsearch等搜索引擎建立索引时，分为正排索引和倒排索引，个人理解是，先通过倒排去找到需要的文档编号，再通过正排根据文档编号找对应信息。<br>
    正排：相当于一个网页拆分成多个关键词，比如网页A=关键词1+关键词2+关键词3+关键词4+关键词5+关键词6+关键词7+......,即Doc1: [Term1, Pos1], [Term2, Pos2], ...。易维护；缺点是搜索的耗时太长；<br>
    倒排：相当于一个关键词对应多个网页，比如关键词1=网页A+网页B+网页C+网页O+....，即Term1: [Doc1, Pos1], [Doc2, Pos2], ...。与正排刚好相反。<br>
    
    
